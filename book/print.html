<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introducción a la terminal</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introducción y motivación</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="historia.html"><strong aria-hidden="true">1.1.</strong> Un poco de historia</a></li><li class="chapter-item expanded "><a href="meta.html"><strong aria-hidden="true">1.2.</strong> Notas sobre este curso</a></li></ol></li><li class="chapter-item expanded "><a href="first_steps.html"><strong aria-hidden="true">2.</strong> Primeros pasos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nav.html"><strong aria-hidden="true">2.1.</strong> Navegación</a></li><li class="chapter-item expanded "><a href="files.html"><strong aria-hidden="true">2.2.</strong> Moviendo y manipulando archivos</a></li><li class="chapter-item expanded "><a href="utils.html"><strong aria-hidden="true">2.3.</strong> Otros comandos útiles</a></li></ol></li><li class="chapter-item expanded "><a href="plumbing.html"><strong aria-hidden="true">3.</strong> Un poco de plomería</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="showoff.html"><strong aria-hidden="true">3.1.</strong> La terminal es muy poderosa</a></li></ol></li><li class="chapter-item expanded "><a href="next_steps.html"><strong aria-hidden="true">4.</strong> Siguientes pasos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="customization.html"><strong aria-hidden="true">4.1.</strong> Customización</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">4.2.</strong> Comandos más avanzados</a></li><li class="chapter-item expanded "><a href="scripting.html"><strong aria-hidden="true">4.3.</strong> Scripting</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introducción a la terminal</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introducción-y-motivación"><a class="header" href="#introducción-y-motivación">Introducción y motivación</a></h1>
<p>Muchas personas argumentan que las <em>terminales</em> son herramientas de
una época pasada. Que todo lo que puede hacer una computadora puede y
se debería hacer con una interfaz gráfica bonita, y un mouse. Si bien
es cierto que las terminales son herencia de una época distinta,
creemos que dan a los usuarios poder, flexibilidad y eficiencia como
pocas otras herramientas pueden dar. En una época en la que la
tendencia es reducir la interacción con el cómputo a dar clicks a la
menor cantidad posible de botones, creemos que aprender a usar tu
terminal te dará poderes insospechados. La curva de aprendizaje puede
ser pronunciada, pero vale la pena.</p>
<h2 id="a-todo-esto-qué-es-una-terminal"><a class="header" href="#a-todo-esto-qué-es-una-terminal">A todo esto ¿qué es una terminal?</a></h2>
<p>Una terminal (a.k.a línea de comandos, consola) es una herramienta que
da acceso a los servicios de tu sistema operativo a través de una
interfaz de texto. Una terminal corre un <em>shell</em>, un programa que
interpreta (así como Python o R) comandos que tú des, y lleva a cabo
esas instrucciones.</p>
<h2 id="relevancia"><a class="header" href="#relevancia">Relevancia</a></h2>
<p>La terminal como herramienta es quizás más relevante para las personas
que programan. Si bien es muy posible programar todo el tiempo desde
un IDE (Integrated Development Environment), muchas opciones avanzas
de desarrollo como compilación con argumentos, debugging y otras solo
están disponibles a través de la terminal.</p>
<h1 id="un-poco-de-historia"><a class="header" href="#un-poco-de-historia">Un poco de historia</a></h1>
<p>El <em>shell</em> que se va a usar en este curso se llama bash. Bash como
casi toda la computación moderna nace en Bell Labs (Hoy en día AT&amp;T)
en los 70s con el desarrollo de UNIX. UNIX fue uno de los primeros
sistemas operativos modernos e influenció a casi todos los que hoy
conocemos, entre ellos MacOS y Linux.</p>
<p>La manera de interactuar con UNIX era a través de un teclado, y una
máquina de escribir conectada a un mainframe y una impresora que
imprimía en papel físico, línea por línea, los comandos que se
enviaban a UNIX. Las computadoras ocupaban cuartos enteros y se
compartían entre muchos usuarios. El mainframe era el nodo central, y
las estaciones con teclados se llamaban <em>terminales</em>, de ahí el
nombre.</p>
<p><img src="figs/dennis_y_ken.png" alt="Ken Thompson y Dennis Ritchie" /></p>
<p>Como toda la interacción era a través de texto, sin posibilidades de
gráficas de ningún tipo, la interfaz de las terminales se diseñó para
ser eficiente y para tener comandos cortos y simples. Esa misma
motivación es la que hizo de las terminales una herramienta muy
eficiente. La terminal era en ese entonces y sigue siendo ahora una
herramienta muy poderosa que permite interactuar con casi todo lo que
el sistema operativo puede ofrecer.  Desde navegación básica y
creación de archivos hasta configuración avanzada.</p>
<p>Linux y MacOS son descendientes de la tradición UNIX y preservan
muchas de las decisiones de diseño que introdujo.</p>
<h1 id="notas-sobre-este-curso"><a class="header" href="#notas-sobre-este-curso">Notas sobre este curso</a></h1>
<p>Este curso asume que se usa bash, pero para los comandos básicos como
los aquí cubiertos es equivalente usar zsh, fish, csh u otra opción.
En este curso se asume que estás trabajando en una máquina Linux,
MacOS, o bien Windows pero con bash instalado. Bash no está instalado
por defecto en windows, pero se puede instalar mediante el paquete de
desarrollo de git.</p>
<blockquote>
<p>La notación usual para estas notas es usar fuentes monoespaciadas
(como <code>asi</code>) para denotar un comando, el resultado de un comando, o
algo que se debe de escribir en la terminal. A veces se usa también
para nombres de archivo y carpetas si se está haciendo referencia a
la salida de un comando.</p>
</blockquote>
<p>Estas notas están basadas en varias fuentes. Entre ellas:</p>
<ol>
<li>
<p><a href="https://ubuntu.com/tutorials/command-line-for-beginners#1-overview">The Linux command line for
beginners</a></p>
</li>
<li>
<p><a href="https://missing.csail.mit.edu/2020/course-shell/">The Missing Semester. Lesson
1</a></p>
</li>
<li>
<p>[How Linux Works - Brian Ward]</p>
</li>
</ol>
<h1 id="primeros-pasos"><a class="header" href="#primeros-pasos">Primeros pasos</a></h1>
<h2 id="cómo-abro-una-de-esas-terminales"><a class="header" href="#cómo-abro-una-de-esas-terminales">¿Cómo abro una de esas terminales?</a></h2>
<h3 id="para-linux-y-macos"><a class="header" href="#para-linux-y-macos">Para Linux y MacOS:</a></h3>
<p>Abre la carpeta o menú donde usualmente están tus aplicaciones, y
busca &quot;terminal&quot;. En MacOS al escribir terminal en la barra de
Spotlight saldrá la terminal pre instalada. Esa es suficiente por
ahora.</p>
<p>En Linux las instrucciones específicas dependen de al distribución,
window manager y desktop environment. Un atajo rápido que funciona en
la mayoría de las distros es la combinación de teclas <code>ctrl + alt + t</code></p>
<h3 id="para-windows"><a class="header" href="#para-windows">Para Windows:</a></h3>
<p>La forma más fácil de obtener bash es descargando git
<a href="https://git-scm.com/downloads">aquí</a>. Después de eso puedes buscar
&quot;git bash&quot; en el menú windows y abrirlo.</p>
<p>En todas las plataformas si usas un IDE o un editor de texto como
Visual Studio Code es muy probable que ya tenga una terminal
integrada. Puedes abrir esa.</p>
<h2 id="una-vez-instalado"><a class="header" href="#una-vez-instalado">Una vez instalado</a></h2>
<p>Al abrir la terminal aparecerá una pantalla con texto, y probablemente
una línea de texto con lo siguiente:</p>
<pre><code class="language-bash">user@host:~$
</code></pre>
<p>Esta línea se suele llamar <em>prompt</em> y quiere decir un par de cosas. La
línea empieza con la palabra <code>user</code> en este caso. En tu caso mostrará
tu nombre de usuario en la computadora. La siguiente palabra, en este
caso <code>host</code> es el nombre de la computadora en
la que se está trabajando.  Separado por <code>:</code> está un <em>tilde</em> (<code>~</code>).
Después de los dos puntos encontramos el nombre de la carpeta actual.
La tilde es una abreviación para la carpeta &quot;home&quot; en tu sistema.
Finalmente, hay un signo <code>$</code>. El cursor siempre aparece después de él,
e indica que se pueden empezar a escribir comandos.</p>
<p>A partir de ahora adoptamos la convención de omitir el hostname y
directorio actual (current working directory). Las líneas de código
que comiencen con <code>$</code> deben ser interpretadas como una nueva línea en
la terminal. Por ejemplo, puedes correr este primer comando:</p>
<pre><code class="language-bash">$ echo &quot;Hola Mundo&quot;
Hola mundo
</code></pre>
<h1 id="navegación"><a class="header" href="#navegación">Navegación</a></h1>
<p>En la sección pasada mencionamos que bash siempre muestra el
directorio actual en la línea de comandos, y lo llamamos current
working directory. Es importante tener en mente que la terminal
siempre tiene este concepto de directorio actual presente. Es como
abrir una ventana del explorador, siempre está abierta en una carpeta,
y los cambios que se hagan van a suceder <em>en esa carpeta</em>. Con la
terminal es similar, los comandos que se den tendrán efecto sobre los
archivos y carpetas en el directorio actual. Además de verlo en la
línea de comandos que da bash puedes usar un comando para obtener el
<em>path</em><sup class="footnote-reference"><a href="#1">1</a></sup> completo.</p>
<pre><code class="language-bash">$ pwd
/Users/alonsoc1s/Documents/itam4code/Cursos/shell/src
</code></pre>
<p>Los <em>paths</em> que comienzan con <code>/</code> se llaman absolutos porque dan una
dirección desde la raíz del sistema de archivos. El directorio (o
carpeta) <code>/</code> es especial, pues es el directorio que contiene a todos
los otros. Otro directorio especial es <code>~</code> (tilde), que es el
directorio &quot;home&quot; del usuario actual. Por ejemplo, para mi es
<code>/Users/alonsoc1s</code>. Los <em>paths</em> que no empiezan con <code>/</code> se llaman
relativos, y se interpretan como la dirección a algo a partir de el
directorio actual.</p>
<p>Otras abreviaturas importantes son el directorio <code>.</code> que se refiere al
directorio actual, y <code>..</code> que se refiere a el directorio padre. Por
ejemplo, puedes navegar una carpeta arriba con <code>cd ..</code>. Más tarde lo
veremos con más detalle.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>La palabra path se refiere a la dirección completa de un archivo
o carpeta en tu sistema de archivos. Ayuda pensar que es como el
camino que se debería seguir al navegar por el sistema de archivos
para llegar hasta un lugar</p>
</div>
<p>Dadas las limitaciones de una interfaz de texto hay algunas cosas que
nos gustaría saber hacer. Por ejemplo listar los contenidos de la
carpeta actual, eliminar archivos, renombrarlos, moverlos, y movernos
entre carpetas, entre otras cosas.</p>
<h2 id="trabajando-con-carpetas-y-archivos"><a class="header" href="#trabajando-con-carpetas-y-archivos">Trabajando con carpetas y archivos</a></h2>
<p>Para listar los contenidos del directorio actual se usa el comando
<code>ls</code>. Mnemónico útil: <strong>l</strong>i<strong>s</strong>t</p>
<pre><code class="language-bash">$ ls
book
book.toml
figs
src
</code></pre>
<p>En este ejemplo en mi directorio actual tengo algunas carpetas y
algunos archivos. Puedes notar cual es cual porque los archivos suelen
tener extensiones (como <code>.toml</code> en el caso de <code>book</code>). En algunas
terminales y en shells más modernos <code>ls</code> colorea el listado para hacer
notar si son carpetas, archivos de texto, ejecutables, etc... Si todo
falla puedes usar el comando <code>file</code> para obtener más información.</p>
<pre><code class="language-bash">$ file src # Usando file con una carpeta
src: directory

$ file book.toml # Usando file con un archivo
book.toml: UTF-8 Unicode text
</code></pre>
<p>Un comando no-estándar muy útil para ver la estructura de árbol del
sistema de archivos es el adecuadamente llamado <code>tree</code>.</p>
<pre><code class="language-bash">$ tree
.
|-- book
|   |-- 404.html
|   |-- files.html
|   |-- fonts
|   |   `-- source-code-pro-v11-all-charsets-500.woff2
|   `-- utils.html
|-- book.toml
`-- src
    |-- SUMMARY.md
	|-- figs
	|   `-- dennis_y_ken.png
	`-- utils.md

9 directories, 74 files
</code></pre>
<p>Para navegar en el sistema de archivos o en otras palabras, cambiar de
directorio, está el comando <code>cd</code> que es abreviatura de <strong>c</strong>hange
<strong>d</strong>irectory. <code>cd</code> te permite moverte dando paths relativos o
absolutos. Dando un path relativo la navegación es como navegar con el
mouse, vas a subcarpetas del directorio actual o subes una carpeta.
Navegar con paths absolutos nos permite dar brincos entre cualesquiera
dos lugares del sistema de archivos. Tomando el ejemplo anterior,
podemos navegar a la carpeta <code>src</code>, o navegar a otra parte
completamente diferente.</p>
<pre><code class="language-bash">$ cd src # Entrando a la carpeta src del directorio actual
$ cd ~/Documents/otroproyecto # Brincando a un lugar completamente distinto
</code></pre>
<p>Los comandos como <code>ls</code> también pueden tomar &quot;flags&quot; o modificadores.
Por ejemplo, <code>ls</code> tiene flags para ver a quién le pertenecen los
contenidos de un directorio y cuando se modificaron por última vez.
El modificador <code>-l</code>da los detalles de propietario y fecha de
modificación tamaño en bytes, entre otros, mientras que <code>-a</code> es corto
para <code>--all</code> y hace que <code>ls</code> muestre incluso los archivos ocultos<sup class="footnote-reference"><a href="#3:">2</a></sup>.</p>
<pre><code class="language-bash">$ ls -l -a
total 32
drwxr-xr-x   8 alonsoc1s  staff   256 Mar  9 14:08 .
drwxr-xr-x   9 alonsoc1s  staff   288 Mar  8 23:09 ..
-rw-r--r--@  1 alonsoc1s  staff  6148 Mar  9 08:36 .DS_Store
-rw-r--r--   1 alonsoc1s  staff     5 Mar  8 21:13 .gitignore
drwxr-xr-x  33 alonsoc1s  staff  1056 Mar  9 14:37 book
-rw-r--r--   1 alonsoc1s  staff   124 Mar  8 21:13 book.toml
drwxr-xr-x   4 alonsoc1s  staff   128 Mar  8 23:03 figs
drwxr-xr-x  15 alonsoc1s  staff   480 Mar  8 21:33 src
</code></pre>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>En los sistemas estilo UNIX es común tener archivos ocultos.
Estos archivos suelen guardar configuraciones o carpetas protegidas
o restringidas. Por ejemplo el archivo <code>.gitignore</code> presente en esta
carpeta configura los tipos de archivos que queremos que git ignore.</p>
</div>
<p>Por ahora no importan los detalles del output del comando anterior,
solo la sintaxis para dar modificadores a un comando. La sintaxis
estándar es <code>-</code> y una letra, o bien <code>--</code> y el nombre largo del
modificador. Bash valora mucho la eficiencia, entonces los nombres de
los comandos son lo más cortos posibles, como una letra. El ejemplo
anterior se puede hacer aún más corto! Cuando se tienen varios
argumentos de una sola letra se pueden combinar bajo el mismo <code>-</code> para
formar algo como:</p>
<pre><code class="language-bash">$ ls -la
</code></pre>
<p>En ocasiones se puede poner tan <del>ridículo</del> complejo como</p>
<pre><code class="language-bash">$ curl -fsSL
</code></pre>
<h2 id="creando-carpetas"><a class="header" href="#creando-carpetas">Creando carpetas</a></h2>
<p>Para crear un directorio podemos usar el comando <code>mkdir</code>. Es fácil
recordar el nombre porque casi se lee &quot;makedir&quot;. Vale la pena hacer
notar que <code>mkdir</code> es más poderoso y versátil que dar click derecho en
el explorador de archivos y dar click a la opción &quot;nueva carpeta&quot;.
Tareas que tomarían repetir la misma operación varias veces, como
crear carpetas anidadas, muchas carpetas a la vez, o crear carpetas
por lote, se pueden hacer en una solo línea.</p>
<p>Primero un ejemplo de crear una carpeta vacía en el directorio actual.</p>
<pre><code class="language-bash">$ mkdir nueva_carpeta
</code></pre>
<p>Usando el modificador <code>-p</code> (corto para parent) podemos anidar carpetas
a la profundidad que queramos. No importa si las carpetas contenedoras
(padre) existen o no!</p>
<pre><code class="language-bash">$ mkdir nueva_carpeta/carpeta_hija # No necesitamos -p porque ya existe carpeta padre
$ mkdir -p otra_nueva/hija_1/hija_2 # Necesitamos -p porque no existía la carpeta padre otra_nueva
</code></pre>
<p>También podemos crear muchas carpetas en un solo comando, estén o no a
la misma profundidad.</p>
<pre><code class="language-bash">$ mkdir carp_1 carp_2 carp_3
</code></pre>
<h2 id="una-manera-de-crear-archivos"><a class="header" href="#una-manera-de-crear-archivos">Una manera de crear archivos</a></h2>
<p>Bash da muchas opciones para crear nuevos archivos e incluso nos deja
ponernos muy creativos. Una de las opciones más fáciles es usando el
comando <code>touch</code> con el nombre del archivo nuevo.</p>
<pre><code class="language-bash">$ touch nuevo_archivo.txt
</code></pre>
<p>El archivo <code>nuevo.txt</code> estará vacío y se creará con la extensión
específica. Técnicamente <code>touch</code> hace más que crear archivos, pero es
muy útil para crearlos rápidamente.</p>
<p>Una manera más divertida de crear archivos es crearlos
<em>redireccionando</em> el resultado de otros comandos y guardarlo en un
archivo nuevo. Por ejemplo, usando <code>ls</code> podemos guardar en un archivo
nuevo llamado <code>carpetas.txt</code> todas las carpetas presentes en el
directorio actual.</p>
<pre><code class="language-bash">$ ls &gt; carpetas.txt
</code></pre>
<p>El operador <code>&gt;</code> redirige el <em>output</em> que resulta de correr <code>ls</code>.
Usualmente <code>ls</code> y la mayoría de comandos imprimen en la terminal sus
resultados. Ese texto es tomado por <code>&gt;</code> y enviado como contenido a un
archivo. Por ejemplo, otra manera de crear un archivo con texto
predeterminado se puede hacer con <code>echo</code>.</p>
<pre><code class="language-bash">$ echo &quot;# Esto es un readme&quot; &gt; README.md
</code></pre>
<p>Como mencionamos antes <code>echo</code> hace lo que el nombre sugiere: toma
texto y lo imprime tal cual en la terminal. En el ejemplo anterior
está tomando el texto &quot;# Esto es un readme&quot; y lo está escribiendo tal
cual en archivo <code>README.md</code>. Si no existía lo crea, pero si ya existía
borra los contenidos anteriores y los reemplaza. Si no es eso lo que
queremos y preferimos añadir al contenido anterior podemos usar el
operador <code>&gt;&gt;</code>, que funciona exactamente igual pero evita perder la
información que ya estaba en el archivo.</p>
<h3 id="ejemplo-de-uso-común"><a class="header" href="#ejemplo-de-uso-común">Ejemplo de uso común</a></h3>
<p>El comando <code>cat</code> sigue bien la tradición de nombres cortos y auto
descriptivos. En este caso es corto para &quot;concatenate&quot;, y hace justo
eso. Recibe como argumentos nombres de archivos, y pega los contenidos
de éstos uno detrás de otro. Esto es muy útil en muchas situaciones.</p>
<p>Por ejemplo, si se tienen dos o más archivos, ¿cómo juntar sus
contenidos en un archivo nuevo? Usando un mouse la solución obvia
sería abrir cada archivo uno por uno, copiar sus contenidos y pegarlos
en algún otro lugar. Usando la terminal esto se puede hacer
escribiendo una sola línea de texto:</p>
<pre><code class="language-bash">$ cat autores.txt contenido.txt &gt;&gt; doc.txt
</code></pre>
<p>Podría parecer que este es un ejemplo de juguete, y hasta cierto punto
lo es. Pero es una situación que surge comúnmente en la práctica y se
puede hacer aún más poderoso. Por ejemplo, ¿qué tal si hay demasiados
archivos como para listarlos uno por uno? Por ejemplo, digamos que hay
muchos archivos de texto que guardan notas de clase y están numerados
por clase y necesitas todo en un solo archivo. Pensando que los
archivos se llaman <code>clase_1.txt, clase_2.txt, ...</code> y así
sucesivamente, podemos usar el siguiente comando.</p>
<pre><code class="language-bash">$ cat clase_*.txt &gt;&gt; clases.txt
</code></pre>
<p>El <code>*</code> permite seleccionar todos los números al final del nombre de
los archivos. Hay otra variedad de patrones que permiten seleccionar
archivos dependiendo de patrones, pero lo veremos más tarde. El
concepto de redirección también lo revisaremos más tarde. ¿Ya se
empieza a ver el poder de la terminal?</p>
<h3 id="entonces-se-supone-que-me-sepa-todos-los-modificadores-posibles"><a class="header" href="#entonces-se-supone-que-me-sepa-todos-los-modificadores-posibles">Entonces ¿se supone que me sepa <strong>todos</strong> los modificadores posibles?</a></h3>
<p>Usualmente solo se usan un par de argumentos para algún comando,
dependiendo de qué uso común le demos. Pero no es necesario saberlos
todos. Casi todos los comandos de bash e incluso los que se puedan
instalar aparte por el usuario tienen un argumento especial: <code>-h</code>,
corto para <code>--help</code>. Por ejemplo, podemos ver los posibles argumentos
de <code>cat</code> así.</p>
<pre><code class="language-bash">$ cat --help
Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s) to standard output.

With no FILE, or when FILE is -, read standard input.

  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines, overrides -n
  -e                       equivalent to -vE
  -E, --show-ends          display $ at end of each line
  -n, --number             number all output lines
  -s, --squeeze-blank      suppress repeated empty output lines
  -t                       equivalent to -vT
  -T, --show-tabs          display TAB characters as ^I
  -u                       (ignored)
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB
      --help     display this help and exit
      --version  output version information and exit

Examples:
  cat f - g  Output f's contents, then standard input, then g's contents.
  cat        Copy standard input to standard output.

GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
Full documentation at: &lt;http://www.gnu.org/software/coreutils/cat&gt;
or available locally via: info '(coreutils) cat invocation'
</code></pre>
<p>Si todo falla, el comando <code>man</code>, de &quot;manual&quot;, te muestra un manual
completo para el uso del comando. Usualmente contiene una sinopsis y
todos los posibles modificadores.</p>
<h1 id="archivos"><a class="header" href="#archivos">Archivos</a></h1>
<p>Ahora revisamos algunas de las tareas básicas del día a día con
respecto a archivos. Por ejemplo, mover, renombrar, copiar y borrar.
Continuamos con el ejemplo de la sección anterior con una carpeta que
se ve así:</p>
<pre><code class="language-bash">$ ls
book
book.toml
src
</code></pre>
<h2 id="moviendo-archivos"><a class="header" href="#moviendo-archivos">Moviendo archivos</a></h2>
<p>Por ejemplo, si decidimos que el archivo <code>book.toml</code> debería estar en
la carpeta <code>book</code>, podemos usar el comando <code>mv</code> (<strong>m</strong>o<strong>v</strong>e).</p>
<pre><code class="language-bash">$ mv book.toml book
</code></pre>
<p>Una vez más, el usar una terminal nos permite ahorrarnos algunos pasos
extra que tendríamos que dar trabajando con el explorador gráfico de
archivos. Por ejemplo, si hay un archivo <code>importante.txt</code> dentro de la
carpeta <code>book</code> y queremos moverlo a la carpeta actual, un primer
instinto sería movernos dentro de <code>book</code> con <code>cd</code>, y mover el archivo
hacia arriba con <code>mv importante.txt ..</code> (recordar que <code>..</code> hace
referencia al directorio padre). Pero hay un camino más fácil. Como
podemos referirnos a objetos en el sistema de archivos con paths
relativos y absolutos podemos mover y copiar cosas por todo el árbol
de archivos sin tener que cambiar de carpeta una sola vez. Para este
ejemplo específico podemos usar el comando que está abajo. Nótese que
<code>.</code> hace referencia a la carpeta actual.</p>
<pre><code class="language-bash">$ mv book/importante.txt .
</code></pre>
<p>En este caso <code>mv</code> toma dos argumentos: El primero es el nombre del
archivo que se va a mover, y el segundo es a dónde será movido. Es
decir, primero recibe un nombre de archivo, y luego un nombre de
directorio. Es importante notar que no solo el orden es importante,
sino que darle argumentos diferentes a el mismo comando resulta en
comportamientos diferentes. El caso particular de <code>mv</code> lo revisaremos
ahora mismo.</p>
<h2 id="renombrando-archivos"><a class="header" href="#renombrando-archivos">Renombrando archivos</a></h2>
<p>Cuando se utiliza <code>mv</code> con dos argumentos, ambos nombres de archivos,
<code>mv</code> cambia el nombre del archivo en el primer argumento. En un
ejemplo concreto, tomemos el archivos <code>book.toml</code> y cambiemos el
nombre a <code>libro.toml</code>.</p>
<pre><code class="language-bash">$ mv book.toml libro.toml
$ ls # Usamos ls para verificar que funcionó. No es necesario
book
libro.toml
src
</code></pre>
<h2 id="copiando-archivos"><a class="header" href="#copiando-archivos">Copiando archivos</a></h2>
<p>Copiar archivos es muy simple. El comando para hacerlo se llama <code>cp</code>
(por <strong>c</strong>o<strong>p</strong>y). Su sintaxis es muy similar a la de <code>mv</code>, toma por
primer argumento el nombre del archivo que se va a copiar, y el
segundo argumento es el nombre del archivo copia. Por ejemplo, si
queremos hacer un backup de <code>book.toml</code> lo podemos hacer con el
siguiente comando.</p>
<pre><code class="language-bash">$ cp book.toml book_backup.toml
</code></pre>
<p>Como ya es costumbre, podemos usar paths relativos o absolutos para
copiar cualesquiera dos archivos en el sistema de archivos, sin
importar qué tan lejos estén. Por ejemplo, para la creación de estas
notas usé una foto que ya tenía guardada en mis archivos en otro
carpeta lejana.</p>
<pre><code class="language-bash">$ cp ~/Documents/projects/meme_git.png meme_git.png
</code></pre>
<p>Nótese que el segundo argumento es un nombre de archivo simple, o eso
parece a primera vista. En realidad se puede pensar como un path
relativo! Es un path que apunta directamente al current working
directory. Entonces el comando anterior copia un archivo
<code>meme_git.png</code> localizado en <code>~/Documents/projects/</code> a el directorio
actual con el nombre <code>meme_git.png</code>.</p>
<h2 id="borrando-carpetas-y-archivos"><a class="header" href="#borrando-carpetas-y-archivos">Borrando carpetas y archivos</a></h2>
<blockquote>
<p>ADVERTENCIA: A diferencia de usar un explorador de archivos gráfico,
borrar un archivo o carpeta no envía archivos a una papelera u otro
espacio intermedio. Lo que se borra con estos comandos NO HAY MANERA
DE RECUPERAR.</p>
</blockquote>
<p>Borrar archivos es tan fácil como moverlos o renombrarlos, hay un
comando de nombre fácil de recordar. Ese comando se llama <code>rm</code> por
<strong>r</strong>e<strong>m</strong>ove. A diferencia de por ejemplo <code>mv</code>, <code>rm</code> solo necesita
un argumento: el nombre del archivo a borrar. Sin embargo puede tomar
muchos argumentos y todos ellos serán borrados. Por ejemplo, si
queremos borrar el archivo <code>book.toml</code> el siguiente comando lo hace.</p>
<pre><code class="language-bash">$ rm book.toml
</code></pre>
<p>Realmente no hay mucho más qué decir respecto a borrar archivos, pero
borrar carpetas requiere un poco más de discusión. Si intentamos
borrar una capeta no-vacía con la misma estrategia con la que borramos
un archivo obtendremos un error.</p>
<pre><code class="language-bash">$ rm book
rm: book: is a directory
</code></pre>
<p>Dado que no hay un undo para <code>rm</code>, el comando tiene un poco de
seguridad integrada. Detecta que la carpeta <code>book</code> no está vacía, y
avisa para que no borres una cantidad enorme de archivos por error. Si
efectivamente querías borrar toda la carpeta y sus contenidos hay un
modificador que permite hacer eso: <code>-r</code> por <code>--recursive</code>. Por
ejemplo.</p>
<pre><code class="language-bash">$ rm -r book
</code></pre>
<p>Otro comando para eliminar carpetas es <code>rmdir</code>.</p>
<blockquote>
<p>En foros para principiantes de Linux hay un comando &quot;de broma&quot; muy
común: <code>sudo rm -rf /*</code>. Nunca nunca es buena idea correr este
comando. <code>sudo</code> es un comando que da permisos de
administrador para correr un comando. Puntos extra si logras ver
porqué es mala idea correr este comando.</p>
</blockquote>
<h1 id="otros-comandos-útiles"><a class="header" href="#otros-comandos-útiles">Otros comandos útiles</a></h1>
<p>El contenido de los últimos capítulos puede parecer restrictivo y es
porque si lo es. Esos son apenas los fundamentos para hacer cosas que
ya sabías hacer en tu explorador de archivos. Pero la terminal tiene
mucho más qué ofrecer, y algunas de estas herramientas te pueden ser
muy útiles a la hora de resolver los problemas con los que se suele
encontrar una persona que desarrolla software. Esto es apenas un
teaser, no se cubre ningún comando con particular atención.</p>
<h2 id="grep"><a class="header" href="#grep">Grep</a></h2>
<p>Con el comando <code>grep</code> podemos encontrar texto dentro de archivos u
otros medios de input a la terminal. Lo interesante es que <code>grep</code> no
solo encuentra texto tal cual, sino que está equipado para encontrar
<em>patrones</em> usando un subconjunto de algo llamado &quot;expresiones
regulares&quot; que amerita sus propias notas. Basta saber que <code>*</code> sirve
para encontrar &quot;cualquier cadena de caracteres&quot;, de la misma manera en
la que usamos <code>*</code> antes para seleccionar todos los archivos dentro de
una carpeta. Veremos esto más a detalle.</p>
<p>Por ejemplo, digamos que busco las líneas que contengan la palabra
&quot;terminal&quot; en estas notas.</p>
<pre><code class="language-bash">$ grep terminal *
files.md:Una vez más, el usar una terminal nos permite ahorrarnos algunos pasos
first_steps.md:## ¿Cómo abro una de esas terminales?
first_steps.md:busca &quot;terminal&quot;. En MacOS al escribir terminal en la barra de
historia.md:las estaciones con teclados se llamaban _terminales_
intro.md:Muchas personas argumentan que las _terminales_ son
meta.md:algo que se debe de escribir en la terminal. A veces se usa también
nav.md:working directory. Es importante tener en mente que la terminal
</code></pre>
<p>Grep muestra el nombre del archivo donde encontró una coincidencia,
seguido de la línea donde está.</p>
<h2 id="less"><a class="header" href="#less">Less</a></h2>
<p>A veces nos interesa dar un vistazo rápido a un archivo, y localizarlo
en la terminal para después abrirlo en el explorador de archivos es
muy ineficiente. Para eso existe el comando <code>less</code>. El comando actúa
como un paginador, algo que parte el archivo en la cantidad de líneas
que caben en tu ventana actual. Para avanzar una &quot;página&quot; puedes usar
la barra de espacio, para ir atrás una puedes usar la tecla b. Para
salir presiona q.</p>
<p>El comando <code>man</code> mencionado en la sección sobre navegación utiliza un
paginador muy similar, también puedes salir de ahí presionando q. El
nombre <code>less</code>puede parecer contraintuitivo. Se debe a que es sucesor
de otro paginador llamado <code>more</code> por el texto <code>--MORE--</code> que aparece
en la parte de abajo de la pantalla cuando lo usas.</p>
<h2 id="head--tail"><a class="header" href="#head--tail">Head &amp; Tail</a></h2>
<p>A veces usar <code>less</code> es más de lo necesario. Si necesitas información
de las primeras líneas en un archivo, puedes usar <code>head</code>, y si
necesitas información de las últimas, puedes usar <code>tail</code>. Los nombres
de los comandos son auto-descriptivos. Cabe mencionar que se puede
ajustar el número de líneas que muestran <code>head</code> y <code>tail</code>. ¿Cuál es la
sintaxis para eso? Buen momento para poner en práctica <code>man</code>!</p>
<h2 id="diff"><a class="header" href="#diff">Diff</a></h2>
<p>En muchas ocasiones es útil comparar dos archivos. Por ejemplo,
archivos <code>.csv</code> con muchas filas de datos. Diff permite comparar
archivos línea por línea y solo muestra las líneas que no coinciden.
Si los archivos coinciden en todos lados no muestra nada. Se usa así:</p>
<pre><code class="language-bash">diff archivo_a.csv archivo_b.csv
</code></pre>
<h2 id="find"><a class="header" href="#find">Find</a></h2>
<p>Otra cosa que podrías extrañar de tu explorador de archivos es la
barra de búsqueda. También se pueden buscar archivos en la misma
terminal. Por ejemplo, si sabes con seguridad que buscas un archivo
específico en alguna parte del árbol de archivos puedes buscarlo sin
importar a qué profundidad esté. Por ejemplo, puedo buscar el archivo
<code>meme_git.png</code> de un ejemplo anterior dentro de mis Documentos.</p>
<pre><code class="language-bash">$ find ~/Documents/ -name meme_git.png
</code></pre>
<p>Esta forma de buscar también da el poder de buscar archivos <em>por sus
contenidos</em>, o dando un patrón de búsqueda para el nombre de archivo
al estilo de <code>grep</code>, pero eso es algo avanzado para este curso.</p>
<h2 id="uniq"><a class="header" href="#uniq">Uniq</a></h2>
<p>El comando <code>uniq</code> por default muestra las líneas únicas &quot;no repetidas&quot;
en un archivo de texto. Suele ser muy común pegar dos veces al copiar
una línea, entonces una manera rápida de verificar es usando <code>uniq</code>.
El comando también se puede configurar para solo mostrar las
repetidas, lo cual es útil en archivos de texto como escritos o
scripts, mientras que la configuración estándar es útil por ejemplo
para detectar observaciones repetidas en un archivo de formato <code>.csv</code>.</p>
<pre><code class="language-bash">$ uniq README.md # Encuentra líneas únicas en el archivo.
</code></pre>
<h1 id="un-poco-de-plomería"><a class="header" href="#un-poco-de-plomería">Un poco de plomería</a></h1>
<p>Ya vimos algunos ejemplos de cómo la terminal de mucho poder al
usuario que sabe usarla, su auténtico poder se libera haciendo uso de
las características que precisamente la hacen diferente a trabajar con
un navegador de archivos, por ejemplo. Es bueno recordar que un
<em>shell</em> es un intérprete de comandos en toda la extensión de la
palabra.</p>
<h2 id="inputs-outputs-errores"><a class="header" href="#inputs-outputs-errores">Inputs, outputs, errores</a></h2>
<p>Hasta ahora hemos usado los términos <em>input</em> y <em>output</em> sin mucho
cuidado. Ahora habrá que clarificar su uso, porque son conceptos muy
importantes. El que el <em>shell</em> tenga concepto de esto le permite hacer
mucho más que crear y mover archivos ociosamente. No hay que olvidar
que en tiempos de UNIX ésta era la única manera de interactuar con una
computadora, y muchas personas hacían tareas complejas como procesar
texto, todo sin siquiera acercase a algo como word.</p>
<p>Como mencionamos antes, los comandos tienen un output determinado.
Este se suele mostrar en la terminal justo después de que se corrió el
comando, como lo hemos estado mostrando en estas notas. Los comandos
de bash están diseñados para usar dos canales de comunicación con el
usuario: standard out (stdout) y standard error (stderr). Cuando
creamos un archivo con el comando,</p>
<pre><code class="language-bash">$ ls &gt; contenidos.txt
</code></pre>
<p>redirigimos des stdout hacia otro lugar, en donde bash lo tomó y lo
mandó como contenido al archivo <code>contenidos.txt</code>. Ese lugar se llama
standard in (stdin). Entonces, ahora tenemos un canal para enviar
información a comandos, y dos en los cuales la recibimos. Esta
redirección es mucho más versátil que solo escribir archivos nuevos.</p>
<h2 id="el-pipe"><a class="header" href="#el-pipe">El pipe</a></h2>
<p>El operador <code>&gt;</code> nos permitió redirigir stdout a un archivo. Lo
interesante es que se puede redirigir de stdout directo a stdin para
que otros comandos los puedan leer. Por ejemplo, <code>less</code> tomaba como
argumento un nombre de archivo, pero en realidad no es necesario
dárselo! Si se corre <code>less</code> sin argumentos, tratará de leer de stdin.
En un ejemplo concreto, podemos usar el ejemplo de <code>grep</code> otra vez y
ahora buscar una palabra muy común. Por ejemplo:</p>
<pre><code class="language-bash">$ grep el *
</code></pre>
<p>Ese comando buscará las líneas donde aparezca la palabra &quot;el&quot; en los
archivos que componen éstas notas. Es de esperarse que haya muchos
resultados, por lo que <code>grep</code> llenará la pantalla sin problemas. Si se
quiere hacer una análisis minucioso de las apariciones, <em>scrollear</em>
arriba y abajo en la ventana de la terminal no es lo más cómodo.
Intentemos escribirlo a un archivos!</p>
<pre><code class="language-bash">$ grep el * &gt; resultados.txt
</code></pre>
<p>Ahora podemos usar <code>less</code> para abrir el archivo con más comodidad.</p>
<pre><code class="language-bash">$ less resultados.txt
</code></pre>
<p>Pero, ¿no se siente arcaico crear un archivo intermedio para después
tener que borrarlo? Lo es. Podemos evitar este paso dándolo a <code>less</code>
lo que queremos que nos muestre directamente.</p>
<pre><code class="language-bash">$ grep el * | less
</code></pre>
<p>El caracter <code>|</code> se llama <em>pipe</em> en inglés. En términos simples, toma
el stdout del lado izquierdo y lo manda a stdin para el comando del
lado derecho. Esto se llama &quot;piping&quot; en inglés y me referiré a ello
como &quot;pipear&quot; a falta de una mejor traducción.</p>
<p>En el ejemplo anterior estamos tomando stdout de <code>grep</code>, el listado de
coincidencias como en el ejemplo de la sección anterior, y en vez de
mostrarlo todo al mismo tiempo en la terminal, lo envía como input a
<code>less</code>, que como recordamos, toma ese texto y lo divide en páginas
para facilitar su lectura.</p>
<p>No hay límite para cuantos comandos se pueden encadenar uno tras otro,
y el uso creativo de estos bloques básicos de construcción da para
resultados realmente increíbles. Al principio de las notas se comentó
que la filosofía de diseño UNIX era crear muchos programas pequeños
diseñados para hacer una y solo una cosa muy bien. Ahora debería hacer
más sentido esa decisión de diseño. No se necesitan programas
complicados cuando se tiene los ladrillos y el cemento, y mucha
creatividad.</p>
<p>Los ejemplos más bellos de éste concepto en acción los da el mismísimo
Brian Kernighan en esta <a href="https://www.youtube.com/watch?v=tc4ROCJYbm0">joya
histórica</a>, un documental
de UNIX con la aparición de los iconos Kernighan y Ritchie.</p>
<h1 id="la-terminal-es-muy-poderosa"><a class="header" href="#la-terminal-es-muy-poderosa">La terminal es muy poderosa</a></h1>
<p>El contenido de este capítulo es principalmente ejemplos de cosas muy
poderosas que se pueden lograr con la terminal. La mayoría construye
sobre comandos que ya se han mencionado en las notas. Dicho eso, no
siempre intentan ser claros, es un poco de motivación para perderle
miedo a la terminal.</p>
<h2 id="ya-mero-acabamos"><a class="header" href="#ya-mero-acabamos">¿Ya mero acabamos?</a></h2>
<p>Entre muchas comunidades de personas que programan es común usar las
palabras FIXME y TODO (To Do) dentro de los comentarios de programas
para marcar cosas que quedan pendientes, posibles errores o cosas por
implementar. También es muy común que proyectos no-triviales estén
distribuidos a través de muchas carpetas y muchos archivos. En un solo
archivo se podría &quot;usar <code>ctrl + f</code> para buscar apariciones de estas
palabras, pero hacerlo archivo por archivo es menos que deseable. El
problem se puede resolver así:</p>
<pre><code class="language-bash">$ grep '# TODO\|# FIXME' */* | wc -l
24
</code></pre>
<p>El resultado es un número, el número de apariciones distintas de
líneas que contengan el string &quot;TODO&quot; O &quot;FIXME&quot;. El comando <code>wc</code>
cuenta palabras (<strong>w</strong>ord <strong>c</strong>ount), y cuando se le da el modificador
<code>-l</code> cuenta líneas en vez de palabras.</p>
<h2 id="qué-tanto-escribí"><a class="header" href="#qué-tanto-escribí">¿Qué tanto escribí?</a></h2>
<p>Usando a nuestro nuevo amigo <code>wc</code> podemos contar las palabras usadas
en un archivo de texto. Una vez más, es común tener proyectos
distribuidos en muchas carpetas, en muchos archivos, y correr <code>wc</code> uno
por uno no es divertido. Se puede hacer esto mejor:</p>
<pre><code class="language-bash">$ wc *
wc: figs: read: Is a directory
	 138     817    4942 files.md
      55     319    1917 first_steps.md
      29     240    1451 historia.md
      28     222    1365 intro.md
      24     156    1004 meta.md
     302    1832   11584 nav.md
       1       3      19 next_steps.md
      99     691    4183 plumbing.md
       1       2      12 scripting.md
      28     195    1174 showoff.md
     104     736    4538 utils.md
     830    5274   32787 total
</code></pre>
<p><code>wc</code> sin argumentos muestra de izquierda a derecha, el número de
líneas, el número de palabras y el número de bytes.</p>
<h2 id="terminal-user-interfaces"><a class="header" href="#terminal-user-interfaces">Terminal User Interfaces</a></h2>
<p>Hay una buena cantidad de personas que le tienen tanto cariño a su
terminal que han encontrado maneras de representar solo con texto
elementos gráficos con tal de monitorear su trabajo sin dejar la
terminal. Dos ejemplos notables son <code>htop</code>, y <code>btm</code>.</p>
<p><code>htop</code> es una utilidad que muestra una gráfica de uso de los núcleos
de procesador y una lista de los procesos que están consumiendo más
memoria o poder de procesamiento. Se ve asi:</p>
<p><img src="figs/htop.png" alt="Htop" /></p>
<p>Por su parte, <code>btm</code> es un sucesor espiritual de <code>htop</code> y trata de
hacer lo mismo con más información y una interfaz &quot;más moderna&quot;.</p>
<p><img src="figs/btm.png" alt="Btm" /></p>
<p>Ambos <code>htop</code> y <code>btm</code> tienen propósitos prácticos. Hay otros comandos
menos útiles, como <code>neofetch</code>:</p>
<p><img src="figs/neofetch.png" alt="Neofetch" /></p>
<p>O bien, cowsay, que es poco útil pero tierno:</p>
<pre><code class="language-bash">$ cowsay &quot;Espero que te hayan sido útiles estas notas&quot;

 ________________________________________
/ Expero que te hayan sido útiles estas \
\ notas                                  /
 ----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>
<h1 id="siguientes-pasos"><a class="header" href="#siguientes-pasos">Siguientes pasos</a></h1>
<h1 id="customización"><a class="header" href="#customización">Customización</a></h1>
<h1 id="comandos-más-avanzados"><a class="header" href="#comandos-más-avanzados">Comandos más avanzados</a></h1>
<h1 id="scripting"><a class="header" href="#scripting">Scripting</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
